<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        width: 100%;
        background: black;
      }

      .a-enter-vr-button {
        display: none !important;
      }

      #bottom-ui {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 5px;
        box-sizing: border-box;
        z-index: 5;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
      }

      .scroll-arrow {
        width: 40px;
        height: 40px;
        min-width: 40px;
        font-size: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.6);
        cursor: pointer;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        transition: background 0.3s ease, transform 0.2s ease;
        user-select: none;
        margin: 0 5px;
      }

      .scroll-arrow:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
      }

      #model-info {
        text-align: center;
        flex-grow: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 5px;
        flex-wrap: wrap;
        max-width: calc(100% - 100px);
      }

      #model-name, #model-price {
        font-family: 'Arial', sans-serif;
        border-radius: 6px;
        color: white;
        margin: 2px 0;
        background-color: rgba(0, 0, 0, 0.6);
        display: inline-block;
        font-size: 14px;
        min-width: 100px;
        height: 36px;
        line-height: 36px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        padding: 0 8px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #model-price {
        background-color: rgba(30, 144, 255, 0.7);
      }

      a-scene {
        background: linear-gradient(to bottom, #FFFFFF, #808080);
      }

      #loading-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
        color: white;
        font-family: 'Arial', sans-serif;
      }

      .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 15px;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      #loading-text {
        margin-top: 10px;
        font-size: 16px;
        text-align: center;
        padding: 0 15px;
      }

      @media (min-width: 768px) {
        .scroll-arrow {
          width: 50px;
          height: 50px;
          font-size: 24px;
        }
        
        #model-name, #model-price {
          font-size: 16px;
          height: 40px;
          line-height: 40px;
          min-width: 120px;
        }
        
        #bottom-ui {
          padding: 15px 20px;
        }
      }

      @media (min-width: 1024px) {
        #model-name, #model-price {
          font-size: 18px;
          height: 50px;
          line-height: 50px;
          min-width: 160px;
        }
      }
    </style>
  </head>
  <body>
    <div id="loading-screen">
      <div class="spinner"></div>
      <div id="loading-text">Loading 3D Models...</div>
    </div>

    <div id="bottom-ui">
      <div id="scroll-left" class="scroll-arrow">&#10094;</div>
      <div id="model-info">
        <div id="model-name">Loading...</div>
        <div id="model-price">Loading...</div>
      </div>
      <div id="scroll-right" class="scroll-arrow">&#10095;</div>
    </div>

    <a-scene embedded>
      <a-assets id="dynamic-assets"></a-assets>

      <a-entity id="cameraRig">
        <a-camera position="0 1.6 0" look-controls="enabled: false"></a-camera>
      </a-entity>

      <a-entity id="model-container" position="0 1.6 -10">
        <a-entity id="model-parent" position="0 0 0" drag-rotate scale="5 5 5">
          <!-- Models injected here -->
        </a-entity>
      </a-entity>

      <a-entity environment="preset: default; groundColor: #445; grid: none"></a-entity>
    </a-scene>

    <!-- Drag-Rotate Component -->
    <script>
      AFRAME.registerComponent('drag-rotate', {
        schema: {
          speed: { type: 'number', default: 0.5 }
        },
        init: function () {
          this.pitch = THREE.MathUtils.degToRad(30);
          this.yaw = 0;
          this.dragging = false;
          this.startX = 0;
          this.startY = 0;
          this.updateRotation();

          this.onMouseDown = (e) => {
            this.dragging = true;
            this.startX = e.clientX;
            this.startY = e.clientY;
          };

          this.onMouseMove = (e) => {
            if (!this.dragging) return;
            const dx = e.clientX - this.startX;
            const dy = e.clientY - this.startY;

            this.yaw += dx * 0.02 * this.data.speed;
            this.pitch += dy * 0.02 * this.data.speed;

            this.pitch = THREE.MathUtils.clamp(this.pitch, THREE.MathUtils.degToRad(-90), THREE.MathUtils.degToRad(90));

            this.startX = e.clientX;
            this.startY = e.clientY;
            this.updateRotation();
          };

          this.onMouseUp = () => { this.dragging = false; };

          this.onTouchStart = (e) => {
            if (e.touches.length === 1) {
              this.dragging = true;
              this.startX = e.touches[0].clientX;
              this.startY = e.touches[0].clientY;
            }
          };

          this.onTouchMove = (e) => {
            if (!this.dragging || e.touches.length !== 1) return;
            const dx = e.touches[0].clientX - this.startX;
            const dy = e.touches[0].clientY - this.startY;

            this.yaw += dx * 0.02 * this.data.speed;
            this.pitch += dy * 0.02 * this.data.speed;

            this.pitch = THREE.MathUtils.clamp(this.pitch, THREE.MathUtils.degToRad(-90), THREE.MathUtils.degToRad(90));

            this.startX = e.touches[0].clientX;
            this.startY = e.touches[0].clientY;
            this.updateRotation();
          };

          this.onTouchEnd = () => { this.dragging = false; };

          window.addEventListener('mousedown', this.onMouseDown);
          window.addEventListener('mousemove', this.onMouseMove);
          window.addEventListener('mouseup', this.onMouseUp);
          window.addEventListener('touchstart', this.onTouchStart, { passive: false });
          window.addEventListener('touchmove', this.onTouchMove, { passive: false });
          window.addEventListener('touchend', this.onTouchEnd);
        },
        updateRotation: function () {
          this.el.object3D.rotation.set(this.pitch, this.yaw, 0);
        },
        remove: function () {
          window.removeEventListener('mousedown', this.onMouseDown);
          window.removeEventListener('mousemove', this.onMouseMove);
          window.removeEventListener('mouseup', this.onMouseUp);
          window.removeEventListener('touchstart', this.onTouchStart);
          window.removeEventListener('touchmove', this.onTouchMove);
          window.removeEventListener('touchend', this.onTouchEnd);
        }
      });
    </script>

    <script>
      const scrollLeftBtn = document.getElementById("scroll-left");
      const scrollRightBtn = document.getElementById("scroll-right");
      const modelName = document.getElementById("model-name");
      const modelPrice = document.getElementById("model-price");
      const assets = document.getElementById("dynamic-assets");
      const modelParent = document.getElementById("model-parent");
      const loadingScreen = document.getElementById("loading-screen");
      const loadingText = document.getElementById("loading-text");

      let modelData = [];
      let currentModelIndex = 0;
      let modelEntities = [];

      const ZOOM_MIN = 5;
      const ZOOM_MAX = 12;
      const ZOOM_DEFAULT = 5;
      let zoomFactor = ZOOM_DEFAULT;

      function updateVisibleModel() {
        modelEntities.forEach((model, i) => {
          model.setAttribute('visible', i === currentModelIndex);
        });

        if (modelData.length > currentModelIndex) {
          modelName.innerText = modelData[currentModelIndex].name;
          modelPrice.innerText = `$${modelData[currentModelIndex].price}`;
        }

        zoomFactor = ZOOM_DEFAULT;
        modelParent.setAttribute('scale', `${zoomFactor} ${zoomFactor} ${zoomFactor}`);

        const comp = modelParent.components['drag-rotate'];
        if (comp) {
          comp.pitch = THREE.MathUtils.degToRad(45);
          comp.yaw = 0;
          comp.updateRotation();
        }
      }

      function setupButtonEvents() {
        const changeModel = (dir) => {
          currentModelIndex = (currentModelIndex + dir + modelEntities.length) % modelEntities.length;
          updateVisibleModel();
        };

        scrollLeftBtn.addEventListener("click", () => changeModel(-1));
        scrollRightBtn.addEventListener("click", () => changeModel(1));
        scrollLeftBtn.addEventListener("touchstart", (e) => { e.preventDefault(); changeModel(-1); }, { passive: false });
        scrollRightBtn.addEventListener("touchstart", (e) => { e.preventDefault(); changeModel(1); }, { passive: false });
      }

      async function fetchGoogleSheetCSV() {
        loadingText.textContent = "Fetching model data...";
        
        const proxy = "https://api.allorigins.win/raw?url=";
        const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTKjBezjVa5ZwSJrTxN3rsgZ8GIT3h9ySMyKqEfV1SkSMAge3OPyvh_r9-eK6JQAKza4i0S-0puOo64/pub?gid=0&single=true&output=csv";
        const fullUrl = proxy + encodeURIComponent(sheetUrl + `&t=${Date.now()}`);

        try {
          const response = await fetch(fullUrl);
          const text = await response.text();
          const results = Papa.parse(text, { header: true });
          return results.data.map(row => {
            const cleanRow = {};
            for (let key in row) {
              cleanRow[key.trim()] = row[key];
            }
            return {
              name: cleanRow['Model Name'] || 'Unknown',
              price: cleanRow['Price'] || 'N/A',
              url: cleanRow['Model URL'] || ''
            };
          }).filter(model => model.url);
        } catch (err) {
          console.error('Error fetching or parsing sheet:', err);
          loadingText.textContent = "Error loading data. Please try again.";
          return [];
        }
      }

      function createModelEntities(models) {
        loadingText.textContent = "Loading 3D models...";
        
        return new Promise((resolve) => {
          let loadedCount = 0;
          
          modelEntities = models.map((model, index) => {
            const assetId = `modelAsset${index}`;
            const assetItem = document.createElement('a-asset-item');
            assetItem.setAttribute('id', assetId);
            assetItem.setAttribute('src', model.url);
            assets.appendChild(assetItem);

            const entity = document.createElement('a-gltf-model');
            entity.setAttribute('src', `#${assetId}`);
            entity.setAttribute('rotation', '0 0 0');
            entity.setAttribute('position', '0 0 0');
            entity.setAttribute('scale', '5 5 5');
            entity.setAttribute('visible', 'false');
            
            entity.addEventListener('model-loaded', () => {
              loadedCount++;
              loadingText.textContent = `Loading models (${loadedCount}/${models.length})...`;
              
              if (loadedCount === models.length) {
                setTimeout(() => {
                  loadingScreen.style.opacity = '0';
                  setTimeout(() => {
                    loadingScreen.style.display = 'none';
                    resolve();
                  }, 300);
                }, 500);
              }
            });
            
            modelParent.appendChild(entity);
            return entity;
          });
        });
      }

      function applyZoom() {
        zoomFactor = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, zoomFactor));
        modelParent.setAttribute('scale', `${zoomFactor} ${zoomFactor} ${zoomFactor}`);
      }

      function zoomIn() {
        zoomFactor *= 1.1;
        applyZoom();
      }

      function zoomOut() {
        zoomFactor /= 1.1;
        applyZoom();
      }

      window.addEventListener('load', async () => {
        modelData = await fetchGoogleSheetCSV();
        if (modelData.length > 0) {
          await createModelEntities(modelData);
          updateVisibleModel();
          setupButtonEvents();
        } else {
          loadingText.textContent = "No models available. Please check the data source.";
        }
      });

      window.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (e.deltaY < 0) zoomIn();
        else zoomOut();
      }, { passive: false });

      let initialPinchDistance = null;

      window.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
        }
      });

      window.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2 && initialPinchDistance) {
          e.preventDefault();
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const currentPinchDistance = Math.sqrt(dx * dx + dy * dy);
          const pinchChange = currentPinchDistance / initialPinchDistance;

          if (pinchChange > 1.05) zoomIn();
          else if (pinchChange < 0.95) zoomOut();

          initialPinchDistance = currentPinchDistance;
        }
      }, { passive: false });

      window.addEventListener('touchend', () => {
        initialPinchDistance = null;
      });

      // Handle safe area for mobile devices
      function updateSafeArea() {
        const bottomUI = document.getElementById('bottom-ui');
        const safeAreaBottom = window.visualViewport 
          ? window.visualViewport.height - window.innerHeight
          : 0;
        
        bottomUI.style.paddingBottom = `calc(env(safe-area-inset-bottom, 0px) + ${safeAreaBottom}px)`;
      }

      window.addEventListener('resize', updateSafeArea);
      updateSafeArea();
    </script>
  </body>
</html>
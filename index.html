<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        width: 100%;
        background: black;
      }

      .a-enter-vr-button {
        display: none !important;
      }

      #bottom-ui {
        position: absolute;
        bottom: 20px;
        left: 0;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 20px;
        box-sizing: border-box;
        z-index: 5;
      }

      .scroll-arrow {
        width: 50px;
        height: 50px;
        font-size: 24px;
        color: white;
        background: rgba(0, 0, 0, 0.6);
        cursor: pointer;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        transition: background 0.3s ease, transform 0.2s ease;
        user-select: none;
      }

      .scroll-arrow:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
      }

      #model-info {
        text-align: center;
        flex-grow: 1;
      }

      #model-name, #model-price {
        font-family: sans-serif;
        border-radius: 8px;
        color: white;
        margin: 5px 0;
        background-color: rgba(0, 0, 0, 0.6);
        display: inline-block;
      }

      #model-name {
        padding: 10px 20px;
        font-size: 18px;
      }

      #model-price {
        padding: 6px 16px;
        font-size: 16px;
      }
    </style>
  </head>
  <body>
    <div id="bottom-ui">
      <div id="scroll-left" class="scroll-arrow">&#10094;</div>
      <div id="model-info">
        <div id="model-name">Loading...</div>
        <div id="model-price"></div>
      </div>
      <div id="scroll-right" class="scroll-arrow">&#10095;</div>
    </div>

    <a-scene background="color: black" embedded>
      <a-assets id="dynamic-assets"></a-assets>
      <a-entity id="cameraRig">
        <!-- Disable device motion here -->
        <a-camera position="0 1.6 3" look-controls="enabled: false"></a-camera>
      </a-entity>
      <a-entity id="model-container" position="0 1.6 -3">
        <a-entity id="model-parent" position="0 0 0" drag-rotate="speed: 1.2; sensitivity: 0.5; friction: 0.88">
          <!-- Models dynamically injected here -->
        </a-entity>
      </a-entity>
    </a-scene>

    <!-- 🌀 Improved Drag to Rotate Component with Medium Speed Settings -->
    <script>
      AFRAME.registerComponent('drag-rotate', {
        schema: { 
          speed: { type: 'number', default: 1.2 },
          friction: { type: 'number', default: 0.88 },
          minVelocity: { type: 'number', default: 0.001 },
          sensitivity: { type: 'number', default: 0.5 }
        },
        init: function () {
          this.startX = 0;
          this.startY = 0;
          this.dragging = false;
          this.velocityX = 0;
          this.velocityY = 0;
          this.lastTime = 0;
          this.lastDeltaX = 0;
          this.lastDeltaY = 0;
          
          // Store initial rotation as quaternion
          this.initialRotation = new THREE.Quaternion();
          if (this.el.object3D.quaternion) {
            this.initialRotation.copy(this.el.object3D.quaternion);
          }
          
          // Current rotation state
          this.currentRotation = new THREE.Quaternion();
          this.currentRotation.copy(this.initialRotation);
          
          // Temporary quaternion for calculations
          this.tempQuaternion = new THREE.Quaternion();
          
          // Rotation axes
          this.xAxis = new THREE.Vector3(1, 0, 0);
          this.yAxis = new THREE.Vector3(0, 1, 0);
          
          this.tick = AFRAME.utils.throttleTick(this.tick.bind(this), 16, this);
          
          const start = (clientX, clientY) => {
            this.startX = clientX;
            this.startY = clientY;
            this.dragging = true;
            this.velocityX = 0;
            this.velocityY = 0;
            this.lastDeltaX = 0;
            this.lastDeltaY = 0;
          };
    
          const move = (clientX, clientY) => {
            if (!this.dragging) return;
            
            const deltaX = clientX - this.startX;
            const deltaY = clientY - this.startY;
            
            const now = Date.now();
            const deltaTime = now - (this.lastTime || now);
            this.lastTime = now;
            
            if (deltaTime > 0) {
              const smoothDeltaX = (deltaX + this.lastDeltaX) / 2;
              const smoothDeltaY = (deltaY + this.lastDeltaY) / 2;
              
              this.velocityX = (smoothDeltaX * this.data.sensitivity * this.data.speed) / deltaTime;
              this.velocityY = (-smoothDeltaY * this.data.sensitivity * this.data.speed) / deltaTime;
              
              this.lastDeltaX = deltaX;
              this.lastDeltaY = deltaY;
            }
            
            this.startX = clientX;
            this.startY = clientY;
            
            // Apply rotation using quaternions
            const yRotation = new THREE.Quaternion().setFromAxisAngle(
              this.yAxis, 
              deltaX * 0.009 * this.data.speed * this.data.sensitivity
            );
            
            const xRotation = new THREE.Quaternion().setFromAxisAngle(
              this.xAxis, 
              deltaY * 0.009 * this.data.speed * this.data.sensitivity
            );
            
            // Apply y rotation first, then x rotation
            this.tempQuaternion.multiplyQuaternions(yRotation, this.currentRotation);
            this.currentRotation.multiplyQuaternions(xRotation, this.tempQuaternion);
            
            // Limit x rotation (up/down) to prevent flipping
            const euler = new THREE.Euler().setFromQuaternion(this.currentRotation, 'YXZ');
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.currentRotation.setFromEuler(euler);
            
            this.el.object3D.quaternion.copy(this.currentRotation);
          };
    
          const stop = () => {
            this.dragging = false;
          };
    
          document.body.addEventListener('mousedown', (e) => start(e.clientX, e.clientY));
          document.body.addEventListener('mousemove', (e) => move(e.clientX, e.clientY));
          document.body.addEventListener('mouseup', stop);
    
          document.body.addEventListener('touchstart', (e) => {
            start(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
          }, { passive: false });
    
          document.body.addEventListener('touchmove', (e) => {
            move(e.touches[0].clientX, e.touches[0].clientY);
            e.preventDefault();
          }, { passive: false });
    
          document.body.addEventListener('touchend', stop);
        },
        
        tick: function(time, timeDelta) {
          if (!this.dragging && (Math.abs(this.velocityX) > this.data.minVelocity || 
                                 Math.abs(this.velocityY) > this.data.minVelocity)) {
            const easingFactor = 1 - Math.pow(1 - this.data.friction, timeDelta / 16);
            
            // Apply rotation using quaternions
            const yRotation = new THREE.Quaternion().setFromAxisAngle(
              this.yAxis, 
              this.velocityX * easingFactor * 0.01
            );
            
            const xRotation = new THREE.Quaternion().setFromAxisAngle(
              this.xAxis, 
              this.velocityY * easingFactor * 0.01
            );
            
            // Apply y rotation first, then x rotation
            this.tempQuaternion.multiplyQuaternions(yRotation, this.currentRotation);
            this.currentRotation.multiplyQuaternions(xRotation, this.tempQuaternion);
            
            // Limit x rotation (up/down) to prevent flipping
            const euler = new THREE.Euler().setFromQuaternion(this.currentRotation, 'YXZ');
            euler.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, euler.x));
            this.currentRotation.setFromEuler(euler);
            
            this.el.object3D.quaternion.copy(this.currentRotation);
            
            this.velocityX *= Math.pow(this.data.friction, timeDelta / 16);
            this.velocityY *= Math.pow(this.data.friction, timeDelta / 16);
            
            if (Math.abs(this.velocityX) < this.data.minVelocity) this.velocityX = 0;
            if (Math.abs(this.velocityY) < this.data.minVelocity) this.velocityY = 0;
          }
        }
      });
    </script>

    <script>
      const scrollLeftBtn = document.getElementById("scroll-left");
      const scrollRightBtn = document.getElementById("scroll-right");
      const modelName = document.getElementById("model-name");
      const modelPrice = document.getElementById("model-price");
      const assets = document.getElementById("dynamic-assets");
      const modelParent = document.getElementById("model-parent");

      let modelData = [];
      let currentModelIndex = 0;
      let modelEntities = [];

      function updateVisibleModel() {
        modelEntities.forEach((model, i) => {
          model.setAttribute('visible', i === currentModelIndex);
        });

        if (modelData.length > currentModelIndex) {
          modelName.innerText = modelData[currentModelIndex].name;
          modelPrice.innerText = modelData[currentModelIndex].price;
        }
      }

      function setupButtonEvents() {
        // Common click/touch handler
        const handleLeftClick = () => {
          currentModelIndex = (currentModelIndex - 1 + modelEntities.length) % modelEntities.length;
          updateVisibleModel();
          modelParent.setAttribute('rotation', { x: 0, y: 180, z: 0 });
          const dragRotate = modelParent.components['drag-rotate'];
          if (dragRotate) {
            dragRotate.velocityX = 0;
            dragRotate.velocityY = 0;
          }
        };

        const handleRightClick = () => {
          currentModelIndex = (currentModelIndex + 1) % modelEntities.length;
          updateVisibleModel();
          modelParent.setAttribute('rotation', { x: 0, y: 180, z: 0 });
          const dragRotate = modelParent.components['drag-rotate'];
          if (dragRotate) {
            dragRotate.velocityX = 0;
            dragRotate.velocityY = 0;
          }
        };

        // Mouse events
        scrollLeftBtn.addEventListener("click", handleLeftClick);
        scrollRightBtn.addEventListener("click", handleRightClick);

        // Touch events
        scrollLeftBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          handleLeftClick();
        }, { passive: false });

        scrollRightBtn.addEventListener("touchstart", (e) => {
          e.preventDefault();
          handleRightClick();
        }, { passive: false });
      }

      async function fetchGoogleSheetCSV() {
        const proxy = "https://api.allorigins.win/raw?url=";
        const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTKjBezjVa5ZwSJrTxN3rsgZ8GIT3h9ySMyKqEfV1SkSMAge3OPyvh_r9-eK6JQAKza4i0S-0puOo64/pub?gid=0&single=true&output=csv";
        const fullUrl = proxy + encodeURIComponent(sheetUrl + `&t=${Date.now()}`);

        try {
          const response = await fetch(fullUrl);
          const text = await response.text();
          const results = Papa.parse(text, { header: true });
          return results.data.map(row => {
            const cleanRow = {};
            for (let key in row) {
              cleanRow[key.trim()] = row[key];
            }
            return {
              name: cleanRow['Model Name'] || 'Unknown',
              price: cleanRow['Price'] || 'N/A',
              url: cleanRow['Model URL'] || ''
            };
          }).filter(model => model.url);
        } catch (err) {
          console.error('Error fetching or parsing sheet:', err);
          return [];
        }
      }

      function createModelEntities(models) {
        modelEntities = models.map((model, index) => {
          const assetId = `modelAsset${index}`;
          const assetItem = document.createElement('a-asset-item');
          assetItem.setAttribute('id', assetId);
          assetItem.setAttribute('src', model.url);
          assets.appendChild(assetItem);

          const entity = document.createElement('a-gltf-model');
          entity.setAttribute('src', `#${assetId}`);
          entity.setAttribute('rotation', '0 180 0');
          entity.setAttribute('position', '0 0 0');
          entity.setAttribute('scale', '15 15 15');
          entity.setAttribute('visible', 'false');
          modelParent.appendChild(entity);

          return entity;
        });
      }

      window.addEventListener('load', async () => {
        modelData = await fetchGoogleSheetCSV();
        createModelEntities(modelData);
        updateVisibleModel();
        setupButtonEvents(); // Initialize button events after models are loaded
      });
    </script>
  </body>
</html>